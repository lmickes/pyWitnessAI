import pandas as pd
from typing import Tuple, Optional, Dict, Literal, Iterable
import difflib

ResponseType = Literal["suspectId", "designateId", "fillerId", "rejectId"]

class LineupAIDecision:
    """
    Turn a similarity matrix into a summary of lineup ID results.
    (Similarity matrix: rows=probes, cols=lineup members generated by ImageAnalyzer)

    Similarity = distance (lower is more similar) = confidence (lower is more similar).
    threshold: only select if min distance < threshold; otherwise "rejectId"
    """

    def __init__(self, threshold: float = 100.00,
                 targetLineup: Optional[Literal["targetPresent", "targetAbsent"]] = None,
                 target: Optional[str] = None):
        self.threshold = threshold
        self.targetLineup = targetLineup
        self.target = target

    @staticmethod
    def _role_map_from_lineuploader(lineup_loader) -> Dict[str, str]:
        """
        Map image base name ->
        role: {'guilty_suspect'|'innocent_suspect'|'filler'}
        """
        role_map = {}

        if lineup_loader.perp_name:
            role_map[lineup_loader.perp_name] = "guilty_suspect"
        if lineup_loader.innocent_name:
            role_map[lineup_loader.innocent_name] = "innocent_suspect"
        for _ in lineup_loader.filler_names:
            role_map[_] = "filler"
        return role_map

    @staticmethod
    def _response_type(name: Optional[str], roles: Dict[str, str]) -> ResponseType:
        if name is None:
            return "rejectId"
        role = roles.get(name, "filler")
        if role == "guilty_suspect":
            return "suspectId"
        elif role == "innocent_suspect":
            return "designateId"
        else:
            return "fillerId"

    @staticmethod
    def _min_choice(series:pd.Series, allow: Optional[pd.Index] = None) -> Tuple[Optional[str], float]:
        """
        Return (index of min value, min value); if empty, return (None, inf.)
        """
        s = series

        if allow is not None:
            s = s.loc[allow]
        if s.empty or s.isna().all():
            return None, float("inf")
        idx = s.idxmin()
        return idx, float(s.loc[idx])

    @staticmethod
    def _build_roles_from_target(members: Iterable[str],
                                 targetLineup: Literal["targetPresent", "targetAbsent"],
                                 target: str) -> Dict[str, str]:
        """
        Based on lineup members + targetLineup + target to build roles dict.
        """
        if targetLineup not in ("targetPresent", "targetAbsent"):
            raise ValueError("targetLineup must be 'targetPresent' or 'targetAbsent'.")

        members = list(members)
        if target not in members:
            # Provide suggestions for possible typos
            suggestion = difflib.get_close_matches(target, members, n=3)
            msg = (
                f"target '{target}' is not in the dataframe you provided.\n"
                f"Available members are: {members}"
            )
            if suggestion:
                msg += f"\n Do you mean: {suggestion}?"
            raise ValueError(msg)

        roles = {m: "filler" for m in members}
        if targetLineup == "targetPresent":
            roles[target] = "guilty_suspect"
        else:  # targetLineup == "targetAbsent"
            roles[target] = "innocent_suspect"
        return roles

    def decide_macro(self, sim_df:  pd.DataFrame, roles: Dict[str, str]) -> Dict[str, object]:
        """
        Case1: Both guilty and innocent suspect exist AND user did not set targetLineup
        Return macro table fields:
          filler_min, TA_selected/TP_selected, TA_responseType/TP_responseType, TA_conf/TP_conf
        """
        # 1. Find min lineup member for each probe (each column)
        per_member_min = sim_df.min(axis=0)

        # 2. Identify roles
        guilty_name = next((k for k, v in roles.items() if v == "guilty_suspect"), None)
        innocent_name = next((k for k, v in roles.items() if v == "innocent_suspect"), None)
        filler_names = [k for k, v in roles.items() if v == "filler"]

        # 3. Find the min filler distance
        filler_min_val = float(per_member_min.loc[filler_names].min()) if filler_names else float("inf")

        # 4.1. TA: The minimum among all except the guilty suspect
        allow_TA = per_member_min.index.difference([guilty_name]) if guilty_name in per_member_min.index else per_member_min.index
        TA_sel, TA_conf = self._min_choice(per_member_min, allow=allow_TA)
        if TA_conf >= self.threshold:
            TA_sel = None
        TA_rt = self._response_type(TA_sel, roles)

        # 4.2. TP: The minimum among all except the innocent suspect
        allow_TP = per_member_min.index.difference([innocent_name]) if innocent_name in per_member_min.index else per_member_min.index
        TP_sel, TP_conf = self._min_choice(per_member_min, allow=allow_TP)
        if TP_conf >= self.threshold:
            TP_sel = None
        TP_rt = self._response_type(TP_sel, roles)

        return {
            "filler_min": filler_min_val,
            "TA_selected": TA_sel,
            "TP_selected": TP_sel,
            "TA_responseType": TA_rt,
            "TP_responseType": TP_rt,
            "TA_conf": (None if TA_sel is None else TA_conf),
            "TP_conf": (None if TP_sel is None else TP_conf),
        }

    def decide_tp_or_ta(self, sim_df: pd.DataFrame, roles: Dict[str, str]) -> Dict[str, object]:
        """
        Case2: user specifies targetLineup ('targetPresent' or 'targetAbsent').
        Return:
          filler_min, selected, responseType, confidence
        """
        per_member_min = sim_df.min(axis=0)
        filler_names = [k for k,v in roles.items() if v=="filler"]
        guilty_name = next((k for k,v in roles.items() if v=="guilty_suspect"), None)
        innocent_name = next((k for k,v in roles.items() if v=="innocent_suspect"), None)
        filler_min_val = float(per_member_min.loc[filler_names].min()) if filler_names else float("inf")

        if self.targetLineup == "targetPresent":
            # Allow all members except innocent (or only specified guilty)
            allow = per_member_min.index.difference([innocent_name]) if innocent_name else per_member_min.index
            if self.target is not None:
                # If target is specified, only allow the target
                allow = per_member_min.index.intersection([self.target])

        elif self.targetLineup == "targetAbsent":
            # Allow all members except guilty (or only specified innocent)
            allow = per_member_min.index.difference([guilty_name]) if guilty_name else per_member_min.index
            if self.target is not None:
                allow = per_member_min.index.intersection([self.target])
        else:
            raise ValueError("targetLineup must be 'targetPresent' or 'targetAbsent'")

        sel, conf = self._min_choice(per_member_min, allow=allow)
        if conf >= self.threshold:
            sel = None
        rt = self._response_type(sel, roles)
        return {
            "filler_min": filler_min_val,
            "selected": sel,
            "responseType": rt,
            "confidence": (None if sel is None else conf),
        }

    def decide_for_pipeline(self, sim_df: pd.DataFrame, lineup_loader) -> Dict[str, object]:
        roles = self._role_map_from_lineuploader(lineup_loader)
        has_guilty = any(v=="guilty_suspect" for v in roles.values())
        has_innocent = any(v=="innocent_suspect" for v in roles.values())

        if self.targetLineup is None and has_guilty and has_innocent:
            return self.decide_macro(sim_df, roles)
        elif self.targetLineup in ("targetPresent", "targetAbsent"):
            return self.decide_tp_or_ta(sim_df, roles)
        else:
            # If neither guilty nor innocent exists, or only one exists but targetLineup is not set,
            # just do a simple min choice among all members
            per_member_min = sim_df.min(axis=0)
            filler_names = [k for k,v in roles.items() if v=="filler"]
            filler_min_val = float(per_member_min.loc[filler_names].min()) if filler_names else float("inf")
            sel, conf = self._min_choice(per_member_min)
            if conf >= self.threshold:
                sel = None
            rt = self._response_type(sel, roles)
            return {
                "filler_min": filler_min_val,
                "selected": sel,
                "responseType": rt,
                "confidence": (None if sel is None else conf)
            }

    def decide(self, sim_df: pd.DataFrame) -> Dict[str, object]:
        """
        General interface when only sim_df is provided.
        """
        if self.targetLineup is None or self.target is None:
            raise ValueError(
                "Please set targetLineup ('targetPresent' or 'targetAbsent') and target (keep the name the same with sim_df columns)."
            )

        roles = self._build_roles_from_target(
            members=sim_df.columns,
            targetLineup=self.targetLineup,
            target=self.target
        )
        return self.decide_tp_or_ta(sim_df, roles)

























